<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Jump Runner — Standalone</title>
  <style>
    :root{
      --bg:#0b0f1a;
      --panel:#0f172a;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --blue:#60a5fa;
      --amber:#f59e0b;
      --amber2:#fbbf24;
      --grass:#10b981;
      --ground:#065f46;
      --overlay:rgba(0,0,0,.55);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";}
    .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:24px}
    .container{width:100%;max-width:1100px}
    .top{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
    h1{font-size:24px;margin:0 0 2px 0}
    .sub{font-size:12px;color:var(--muted)}
    .btn{background:#2563eb;color:white;border:0;border-radius:16px;padding:10px 14px;cursor:pointer;box-shadow:0 4px 16px rgba(0,0,0,.25);transition:transform .05s ease, background .2s ease}
    .btn:hover{background:#3b82f6}
    .btn:active{transform:scale(.98)}
    .btn.gray{background:#111827}
    .btn.gray:hover{background:#1f2937}
    .btn.purple{background:#7c3aed}
    .btn.purple:hover{background:#8b5cf6}
    .btn-row{display:flex;gap:8px;flex-wrap:wrap}
    .stage{position:relative;width:100%;aspect-ratio:16/9;background:black;border-radius:16px;overflow:hidden;outline:1px solid #0b1220}
    canvas{display:block;width:100%;height:100%}
    .overlay{position:absolute;inset:0;display:grid;place-items:center;background:var(--overlay);text-align:center}
    .overlay h2{font-size:28px;margin:0 0 8px 0}
    .overlay p{font-size:14px;color:#cbd5e1}
    .mobileJump{position:absolute;right:16px;bottom:16px;padding:16px 18px;border-radius:16px;background:rgba(37,99,235,.85);color:#fff;border:0;font-size:18px;box-shadow:0 8px 24px rgba(0,0,0,.35)}
    .hint{font-size:12px;color:var(--muted);margin-top:8px}
    kbd{background:#111827;color:#e5e7eb;border-radius:6px;padding:2px 6px;font-size:12px}
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="container">
      <div class="top">
        <div>
          <h1>Jump Runner (Web)</h1>
          <div class="sub">SPACE/↑ to jump · Pick a speed level · Dodge blocks and collect artefacts</div>
        </div>
        <div class="btn-row" id="controlsRow">
          <button class="btn" data-level="Chill">Start — Chill</button>
          <button class="btn" data-level="Normal">Start — Normal</button>
          <button class="btn" data-level="Turbo">Start — Turbo</button>
          <button class="btn gray" id="pauseBtn" style="display:none">Pause</button>
          <button class="btn purple" id="restartBtn" style="display:none">Restart</button>
        </div>
      </div>

      <div class="stage" id="stage">
        <canvas id="game"></canvas>
        <div class="overlay" id="startOverlay">
          <div>
            <h2>Choose your speed</h2>
            <p>Chill · Normal · Turbo</p>
          </div>
        </div>

        <div class="overlay" id="pauseOverlay" style="display:none">
          <div>
            <h2>Paused</h2>
            <p>Press <kbd>P</kbd> to resume</p>
          </div>
        </div>

        <div class="overlay" id="gameOverOverlay" style="display:none">
          <div>
            <h2>Game Over</h2>
            <p id="scoreLine" style="margin:0 0 10px 0"></p>
            <button class="btn purple" id="playAgainBtn">Play again</button>
          </div>
        </div>

        <button class="mobileJump" id="jumpBtn" style="display:none">Jump</button>
      </div>

      <div class="hint">Tip: Hold jump briefly for a higher arc. Coins add big points; speed ramps over time. Pause with <kbd>P</kbd>.</div>
    </div>
  </div>

  <script>
  (()=>{
    const canvas = document.getElementById('game');
    const stage = document.getElementById('stage');
    const startOverlay = document.getElementById('startOverlay');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const scoreLine = document.getElementById('scoreLine');
    const pauseBtn = document.getElementById('pauseBtn');
    const restartBtn = document.getElementById('restartBtn');
    const playAgainBtn = document.getElementById('playAgainBtn');
    const jumpBtn = document.getElementById('jumpBtn');
    const controlsRow = document.getElementById('controlsRow');

    const ctx = canvas.getContext('2d');
    const clamp = (n,min,max)=>Math.max(min,Math.min(max,n));
    const rand = (min,max)=>Math.random()*(max-min)+min;

    const state = {
      running:false, paused:false, over:false,
      level:'Normal',
      score:0, coins:0, high: Number(localStorage.getItem('jr_high'))||0,
      t0:0,lastT:0,
      w:960,h:540,dpr:1,
      groundY:460,
      baseSpeed:260, speed:260,
      gravity:1450, jumpVel:520, maxHold:160, holdJumping:false,
      player:{x:140,y:0,r:16,vy:0,onGround:false,squash:0},
      obstacles:[], coinsArr:[], particles:[], clouds:[
        {x:0,y:60,speed:18},{x:300,y:90,speed:12},{x:700,y:40,speed:16}
      ],
      lastObstacle:0, lastCoin:0, obstacleEvery:900, coinEvery:1200,
      raf:null
    };

    function resize(){
      const rect = stage.getBoundingClientRect();
      state.dpr = Math.max(1, Math.floor(window.devicePixelRatio||1));
      canvas.width = Math.floor(rect.width*state.dpr);
      canvas.height= Math.floor(rect.height*state.dpr);
      canvas.style.width = rect.width+'px';
      canvas.style.height= rect.height+'px';
      state.w = canvas.width/state.dpr;
      state.h = canvas.height/state.dpr;
      state.groundY = state.h - 80;
      if(state.player) state.player.y = state.groundY - state.player.r;
    }
    resize();
    new ResizeObserver(resize).observe(stage);
    window.addEventListener('orientationchange', resize);

    // controls
    controlsRow.addEventListener('click', (e)=>{
      const btn = e.target.closest('button[data-level]');
      if(!btn) return;
      start(btn.getAttribute('data-level'));
    });
    pauseBtn.addEventListener('click', ()=>{
      if(!state.running||state.over) return;
      togglePause();
    });
    restartBtn.addEventListener('click', ()=>{
      start(state.level);
    });
    playAgainBtn.addEventListener('click', ()=>{
      start(state.level);
    });
    jumpBtn.addEventListener('mousedown', (e)=>{ e.preventDefault(); triggerJump(); });
    jumpBtn.addEventListener('touchstart', (e)=>{ e.preventDefault(); triggerJump(); });

    // keyboard
    let holdTimer = null;
    window.addEventListener('keydown', (e)=>{
      const k = (e.key||'').toLowerCase();
      if(k===' '||k==='arrowup'){
        e.preventDefault();
        if(state.player.onGround){
          state.player.vy = -state.jumpVel;
          state.player.onGround = false;
          state.holdJumping = true;
          clearTimeout(holdTimer);
          holdTimer = setTimeout(()=>state.holdJumping=false, state.maxHold);
          state.player.squash = -0.22;
        }
      }
      if(k==='p'&&state.running&&!state.over){ togglePause(); }
    });
    window.addEventListener('keyup', (e)=>{
      const k = (e.key||'').toLowerCase();
      if(k===' '||k==='arrowup') state.holdJumping = false;
    });

    function triggerJump(){
      if(state.player.onGround){
        state.player.vy = -state.jumpVel;
        state.player.onGround = false;
        state.holdJumping = true;
        setTimeout(()=>state.holdJumping=false, state.maxHold);
        state.player.squash = -0.22;
      }
    }

    function start(level){
      state.level = level;
      const speeds = {Chill:200, Normal:260, Turbo:320};
      state.baseSpeed = speeds[level]||260;
      state.speed = state.baseSpeed;

      state.player = {x:140,y:state.groundY-16,r:16,vy:0,onGround:true,squash:0};
      state.obstacles = [];
      state.coinsArr = [];
      state.particles = [];
      state.lastObstacle = 0;
      state.lastCoin = 0;
      state.obstacleEvery=900; state.coinEvery=1200;

      state.score=0; state.coins=0;
      state.over=false; state.paused=false; state.running=true;
      state.t0=0; state.lastT=0;

      startOverlay.style.display='none';
      pauseOverlay.style.display='none';
      gameOverOverlay.style.display='none';
      jumpBtn.style.display='block';
      pauseBtn.style.display='inline-block';
      restartBtn.style.display='inline-block';

      cancelAnimationFrame(state.raf);
      state.raf = requestAnimationFrame(tick);
    }

    function endGame(){
      state.running=false; state.over=true; state.paused=false;
      cancelAnimationFrame(state.raf);
      jumpBtn.style.display='none';
      pauseBtn.style.display='none';
      scoreLine.textContent = `Score: ${Math.floor(state.score)} · Coins: ${state.coins} · Best: ${state.high}`;
      gameOverOverlay.style.display='grid';
      if(Math.floor(state.score) > state.high){
        state.high = Math.floor(state.score);
        localStorage.setItem('jr_high', String(state.high));
        scoreLine.textContent += ' — New Best!';
      }
    }

    function togglePause(){
      state.paused = !state.paused;
      if(state.paused){
        pauseOverlay.style.display='grid';
      } else {
        pauseOverlay.style.display='none';
        state.raf = requestAnimationFrame(tick);
      }
    }

    function spawnDust(x,y){
      for(let i=0;i<10;i++){
        state.particles.push({
          x: x + rand(-4,4), y: y + rand(-2,2),
          vx: rand(-80,80), vy: rand(-150,-40),
          g: 600, life: rand(0.25,0.5), maxLife: .5, color: '#d1fae5', r: rand(1,2.5)
        });
      }
    }
    function spawnSparkles(x,y){
      for(let i=0;i<14;i++){
        const a = (i/14)*Math.PI*2;
        state.particles.push({
          x, y, vx: Math.cos(a)*rand(60,140), vy: Math.sin(a)*rand(60,140),
          g: 0, life: rand(0.25,0.6), maxLife:.6, color:'#fde68a', r: rand(1.5,2.5)
        });
      }
    }

    function drawCloud(x,y){
      ctx.save(); ctx.translate(x,y);
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      circle(0,0,18); circle(18,4,14); circle(36,0,20); circle(54,6,14);
      ctx.restore();
    }
    function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }

    function tick(t){
      if(!state.running) return;
      if(!state.t0){ state.t0=t; state.lastT=t; }
      const dt = Math.min(0.033, (t-state.lastT)/1000);
      state.lastT = t;

      // update
      const elapsed = (t-state.t0)/1000;
      state.score = elapsed*10 + state.coins*100;
      state.speed = state.baseSpeed + Math.min(140, elapsed*4);

      // player physics
      if(state.holdJumping && state.player.vy < -20){
        state.player.vy += -520 * dt; // slight counter gravity
      }
      state.player.vy += state.gravity * dt;
      state.player.y += state.player.vy * dt;

      if(state.player.y >= state.groundY - state.player.r){
        if(!state.player.onGround && state.player.vy > 200){ spawnDust(state.player.x, state.groundY-2); }
        state.player.y = state.groundY - state.player.r;
        state.player.vy = 0; state.player.onGround = true;
        state.player.squash = Math.max(state.player.squash, 0.18);
      } else {
        state.player.onGround = false;
      }
      state.player.squash += (0 - state.player.squash) * 6 * dt;

      // spawns
      if(t - state.lastObstacle > state.obstacleEvery){
        state.lastObstacle = t;
        const h = rand(24,60), width = rand(26,52), gap = rand(220,380);
        state.obstacles.push({x: state.w + 20, w: width, h});
        if(Math.random() < 0.6){
          state.coinsArr.push({x: state.w + 20 + width*0.5, y: state.groundY - h - rand(40,110), r: 8});
        }
        if(Math.random() < 0.35){
          state.obstacles.push({x: state.w + 20 + gap, w: rand(22,40), h: rand(20,46)});
        }
      }

      // scroll
      const s = state.speed*dt;
      for(const o of state.obstacles) o.x -= s;
      for(const c of state.coinsArr) c.x -= s;

      // cull
      state.obstacles = state.obstacles.filter(o=>o.x + o.w > -40);
      state.coinsArr = state.coinsArr.filter(c=>c.x + c.r > -20);

      // collisions: obstacles
      for(const o of state.obstacles){
        const px = clamp(state.player.x, o.x, o.x + o.w);
        const py = clamp(state.player.y, state.groundY - o.h, state.groundY);
        const dist = Math.hypot(state.player.x - px, state.player.y - py);
        if(dist <= state.player.r){ endGame(); return; }
      }
      // coins
      for(let i=state.coinsArr.length-1;i>=0;i--){
        const c = state.coinsArr[i];
        const dist = Math.hypot(state.player.x - c.x, state.player.y - c.y);
        if(dist <= state.player.r + c.r){
          spawnSparkles(c.x, c.y);
          state.coinsArr.splice(i,1);
          state.coins += 1;
        }
      }

      // particles
      for(const p of state.particles){
        p.life -= dt; p.x += p.vx*dt; p.y += p.vy*dt; p.vy += (p.g||0)*dt;
      }
      state.particles = state.particles.filter(p=>p.life>0);

      // render
      render(dt, elapsed);

      if(!state.paused) state.raf = requestAnimationFrame(tick);
    }

    function render(dt, elapsed){
      const w = state.w, h = state.h, dpr = state.dpr;
      ctx.save();
      ctx.scale(dpr, dpr);

      // sky gradient
      const g = ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0, '#0ea5e9');
      g.addColorStop(1, '#1f2937');
      ctx.fillStyle=g; ctx.fillRect(0,0,w,h);

      // clouds
      for(const cl of state.clouds){
        cl.x -= cl.speed * dt;
        if(cl.x < -220) cl.x = w + rand(0,180);
        drawCloud(cl.x, cl.y);
      }

      // ground
      const gy = state.groundY;
      ctx.fillStyle = '#065f46';
      ctx.fillRect(0, gy, w, h-gy);
      const tileW = 32; let ox = -((elapsed * state.speed) % tileW);
      ctx.fillStyle = '#10b981';
      for(let x = ox; x < w + tileW; x += tileW){
        ctx.fillRect(x, gy-10, tileW-4, 10);
      }

      // obstacles
      ctx.fillStyle = '#f59e0b';
      for(const o of state.obstacles){
        ctx.fillRect(o.x, gy - o.h, o.w, o.h);
        ctx.fillStyle = '#111827';
        ctx.fillRect(o.x + o.w*0.25, gy - o.h + 10, 4, 6);
        ctx.fillRect(o.x + o.w*0.65, gy - o.h + 10, 4, 6);
        ctx.fillStyle = '#f59e0b';
      }

      // coins
      for(const c of state.coinsArr){
        ctx.beginPath(); ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
        ctx.fillStyle = '#fbbf24'; ctx.shadowColor='rgba(251,191,36,0.8)'; ctx.shadowBlur=10; ctx.fill(); ctx.shadowBlur=0;
        ctx.beginPath(); ctx.arc(c.x - c.r*0.3, c.y - c.r*0.3, c.r*0.4, 0, Math.PI*2);
        ctx.fillStyle='rgba(255,255,255,.6)'; ctx.fill();
      }

      // player (squash & stretch)
      const p = state.player;
      const scaleY = 1 - p.squash;
      const scaleX = 1 + p.squash;
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.scale(scaleX, scaleY);
      ctx.beginPath(); ctx.arc(0,0,p.r,0,Math.PI*2);
      ctx.fillStyle = '#60a5fa'; ctx.shadowColor='rgba(96,165,250,.7)'; ctx.shadowBlur=12; ctx.fill(); ctx.shadowBlur=0;
      ctx.fillStyle = '#111827'; ctx.fillRect(-6,-4,3,4); ctx.fillRect(3,-4,3,4); ctx.fillRect(-3,3,6,2);
      ctx.restore();

      // particles
      for(const pa of state.particles){
        ctx.globalAlpha = Math.max(0, pa.life / pa.maxLife);
        ctx.fillStyle = pa.color;
        if(pa.r){ ctx.beginPath(); ctx.arc(pa.x, pa.y, pa.r, 0, Math.PI*2); ctx.fill(); }
        else { ctx.fillRect(pa.x, pa.y, pa.w||3, pa.h||3); }
        ctx.globalAlpha = 1;
      }

      // HUD
      ctx.fillStyle = '#e5e7eb';
      ctx.font = '600 14px ui-sans-serif,system-ui,-apple-system,Segoe UI';
      ctx.textBaseline = 'top';
      ctx.fillText('Score: ' + Math.floor(state.score), 12, 10);
      ctx.fillText('Coins: ' + state.coins, 12, 28);
      ctx.fillText('Best: ' + state.high, 12, 46);

      ctx.restore();
    }

    // expose for console fun
    window.__JR__ = state;
  })();
  </script>
</body>
</html>
